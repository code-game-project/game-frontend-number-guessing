/*
 * This code was generated by codegame-cli-js.
 * 
 * CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
 * THE CODE IS REGENERATED.
 */

import { createSocket, GameSocket, Verbosity } from '@code-game-project/client';
import type { EventListenerCallback, Session } from '@code-game-project/client';
import type { Events, Commands, GuessCmd, TooHighEvent, TooLowEvent, CorrectEvent, GameConfig } from './event_definitions';

export { Verbosity };

/** Wrapper for number-guessing v0.2. */
export class Game {
  private socket: GameSocket<Commands, Events>;
  private spectating: boolean;

  /**
   * Wraps an instance of `GameSocket`.
   * @param socket A fully ready instance of `GameSocket`.
   * @param spectating Whether the socket is connected to a game as a spectator.
   */
  public constructor(socket: GameSocket<Commands, Events, GameConfig>, spectating: boolean) {
    this.socket = socket;
    this.spectating = spectating;
  }

  /**
   * Creates a new game and joins it.
   * @param gameURL The URL of the game server.
   * @param _public Whether the game should be listed as public.
   * @param _protected Whether the game should require an additional secret to join.
   * @param config Game-specific configuration options.
   * @param username The username to join with.
   * @param verbosity The level of verbosity when logging.
   * @returns an instance of `Game` along with the game ID and optionally a join secret
   */
  public static async createAndJoin<Config extends object = object>(gameURL: string, username: string, _public: boolean, _protected: boolean, config?: Config, verbosity?: Verbosity): Promise<{ game: Game, gameId: string, joinSecret?: string; }> {
    const socket = createSocket<Commands, Events, Config>(gameURL, verbosity);
    const { gameId, joinSecret } = await socket.create(_public, _protected, config);
    await socket.join(gameId, username, joinSecret);
    return { game: new Game(socket, false), gameId, joinSecret };
  }

  /**
   * Joins an existing game.
   * @param gameURL The URL of the game server.
   * @param username The username to join with.
   * @param verbosity The level of verbosity when logging.
   * @param join_secret An additional secret required to join protected games.
   * @returns an instance of `Game`
   */
  public static async join(gameURL: string, gameId: string, username: string, join_secret?: string, verbosity?: Verbosity): Promise<{ game: Game; }> {
    const socket = createSocket<Commands, Events, GameConfig>(gameURL, verbosity);
    await socket.join(gameId, username, join_secret);
    return { game: new Game(socket, false) };
  }

  /**
   * Connects to a game and player using session credentials.
   * @param gameURL The URL of the game server.
   * @param gameId The ID of the game to connect to.
   * @param playerId The ID of the player to connect to.
   * @param playerSecret The player's secret.
   * @param verbosity The level of verbosity when logging.
   * @returns an instance of `Game`
   */
  public static async connect(gameURL: string, gameId: string, playerId: string, playerSecret: string, verbosity?: Verbosity): Promise<{ game: Game; }> {
    const socket = createSocket<Commands, Events, GameConfig>(gameURL, verbosity);
    await socket.connect(gameId, playerId, playerSecret);
    return { game: new Game(socket, false) };
  }

  /**
   * Tries to reconnect using an existing session.
   * @param gameURL The URL of the game server.
   * @param username The username that was used when the session was created.
   * @param verbosity The level of verbosity when logging.
   * @returns an instance of `Game`
   */
  public static async reconnect(gameURL: string, username: string, verbosity?: Verbosity): Promise<{ game: Game; }> {
    const socket = createSocket<Commands, Events, GameConfig>(gameURL, verbosity);
    await socket.restoreSession(username);
    return { game: new Game(socket, false) };
  }

  /**
   * Creates a new game and joins it as a spectator.
   * @param gameURL The URL of the game server.
   * @param _public Whether the game should be listed as public.
   * @param _protected Whether the game should require an additional secret to join.
   * @param config Game-specific configuration options.
   * @param verbosity The level of verbosity when logging.
   * @returns an instance of `Game` along with the game ID and optionally a join secret
   */
  public static async createAndSpectate<Config extends object = object>(gameURL: string, _public: boolean, _protected: boolean, config?: Config, verbosity?: Verbosity): Promise<{ game: Game, gameId: string, joinSecret?: string; }> {
    const socket = createSocket<Commands, Events, Config>(gameURL, verbosity);
    const { gameId, joinSecret } = await socket.create(_public, _protected, config);
    await socket.spectate(gameId);
    return { game: new Game(socket, true), gameId, joinSecret };
  }

  /**
   * Joins an existing game as a spectator.
   * @param gameURL The URL of the game server.
   * @param gameId The ID of the game to connect to.
   * @param verbosity The level of verbosity when logging.
   * @returns an instance of `Game`
   */
  public static async spectate(gameURL: string, gameId: string, verbosity?: Verbosity): Promise<{ game: Game; }> {
    const socket = createSocket<Commands, Events, GameConfig>(gameURL, verbosity);
    await socket.spectate(gameId);
    return { game: new Game(socket, true) };
  }

  /**
   * Gets the current session details.
   * @returns the session
   */
  public getSession(): Readonly<Session | undefined> {
    return this.socket.getSession();
  }

  /**
   * Gets the config of the current game.
   * @returns the config
   */
  public async getConfig(): Promise<Readonly<GameConfig>> {
    const { config } = await this.socket.fetchGameMetadata();
    return config;
  }

  /** Whether the socket is connected to a game as a spectator. */
  public isSpectating(): boolean {
    return this.spectating;
  }

  /**
   * Removes an event listener by ID.
   * @param id The listner's ID. 
   */
  public removeListener(id: symbol) {
    return this.socket.removeListener(id);
  }

  /**
   * Gets a username by player ID.
   * @param playerId The player ID.
   * @returns the username or null if the username is unavailable
   */
  public async getUsername(playerId: string): Promise<string | null> {
    return await this.socket.getUsername(playerId);
  }

  /**
   * Sends a `guess` command.
   * @param data Optional options to go along with your command.
   */
  public sendGuess(data: GuessCmd['data']) {
    return this.socket.send<GuessCmd>('guess', data);
  }

  /**
   * Registers an event listener for the `too_high` event.
   * @param callback Function that is executed when the event is received.
   * @returns the listener's ID
   */
  public onTooHigh(callback: EventListenerCallback<TooHighEvent>): symbol {
    return this.socket.on<TooHighEvent>('too_high', callback);
  }

  /**
   * Registers an event listener for the `too_high` event that will self-destruct after being triggered once.
   * @param callback Function that is executed when the event is received.
   * @returns the listener's ID
   */
  public onTooHighOnce(callback: EventListenerCallback<TooHighEvent>): symbol {
    return this.socket.once<TooHighEvent>('too_high', callback);
  }

  /**
   * Registers an event listener for the `too_low` event.
   * @param callback Function that is executed when the event is received.
   * @returns the listener's ID
   */
  public onTooLow(callback: EventListenerCallback<TooLowEvent>): symbol {
    return this.socket.on<TooLowEvent>('too_low', callback);
  }

  /**
   * Registers an event listener for the `too_low` event that will self-destruct after being triggered once.
   * @param callback Function that is executed when the event is received.
   * @returns the listener's ID
   */
  public onTooLowOnce(callback: EventListenerCallback<TooLowEvent>): symbol {
    return this.socket.once<TooLowEvent>('too_low', callback);
  }

  /**
   * Registers an event listener for the `correct` event.
   * @param callback Function that is executed when the event is received.
   * @returns the listener's ID
   */
  public onCorrect(callback: EventListenerCallback<CorrectEvent>): symbol {
    return this.socket.on<CorrectEvent>('correct', callback);
  }

  /**
   * Registers an event listener for the `correct` event that will self-destruct after being triggered once.
   * @param callback Function that is executed when the event is received.
   * @returns the listener's ID
   */
  public onCorrectOnce(callback: EventListenerCallback<CorrectEvent>): symbol {
    return this.socket.once<CorrectEvent>('correct', callback);
  }

}
